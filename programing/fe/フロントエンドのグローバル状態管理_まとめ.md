## 1. 現代のフロントエンドが抱える「グローバル state 管理」の問題

### ● UI の複雑化によりグローバル state が増えた

- 複数のページ・コンポーネントで共有する state が増加
    
- 認証・ユーザー情報・API キャッシュ・エンティティ・検索条件・UI 状態（モーダル等）が混在
    

### ● グローバル state の課題

- **どこまでを"変更"とみなすかが難しい**
    
- 過剰レンダリング、意図しない再レンダリングが発生
    
- コンポーネント依存関係が複雑化
    
- 状態ライフサイクル（いつ初期化されるべきか）がバラバラ
    
- 管理範囲が曖昧だと "神オブジェクト"（巨大な global state）が生まれる
    

---

## 2. 状態管理ライブラリの差分とは何か

状態管理ライブラリは"状態が変わったとき、どこまでを変更とみなすか"の戦略がそれぞれ大きく異なる。

ここでは、**主要ライブラリの差分戦略の違い**にフォーカスして整理する。

### ● ライブラリごとの差分戦略の比較

|ライブラリ|差分検知方法|通知の単位|UI の再レンダー判断|特徴|
|---|---|---|---|---|
|**Redux**|immutable な参照比較（===）|全体通知|selector の返り値比較|明示的・予測可能。差分は手動最適化型|
|**React Context**|参照比較|Provider 全体|props の参照変化|粒度が粗い。過剰レンダーしやすい|
|**Zustand**|subscribe + selector shallow 比較|selector 単位|selector 結果比較|Redux より粒度細かい手動依存モデル|
|**Jotai**|atom 単位で依存追跡|atom|依存 atom 変化時のみ|値単位の最細粒度。Redux とは真逆の発想|
|**Recoil**|atom + selector の依存グラフ|atom / selector|依存グラフを自動計算|Vue 的な依存トラッキングがある React 版|
|**Vue 3 reactivity**|Proxy による getter/setter フック|プロパティ単位|依存プロパティ変化時のみ|自動依存。暗黙だが最適化されやすい|
|**Pinia**|Vue reactivity に同じ|プロパティ単位|Vue の再レンダー|Vue に最適化された DX|
|**Signals (Solid, React 19+)**|値を "読んだ" 単位で依存登録|キャリア（signal）単位|読み取り式単位|最細粒度・最速。命令的に近い|

---

### ● 差分戦略は3層で構成される

1. **差分検出（どの値が変わったか）**
    
    - immutable 比較（Redux）
        
    - Proxy（Vue）
        
    - atom/signal（Recoil/Jotai/Solid）
        
2. **通知の粒度（どこに伝える？）**
    
    - 全体通知（Redux）
        
    - selector 単位（Zustand）
        
    - プロパティ単位（Vue）
        
    - atom/signal 単位（Jotai/Solid）
        
3. **UI 再レンダーの判断方法**
    
    - selector の === 比較（React-Redux）
        
    - 自動依存追跡（Vue）
        
    - signal 依存（Solid）
        

---

### ● ライブラリが違うと何が変わる？

- **どこまでを"変更"とみなすか**（粒度）
    
- **通知の仕組み**（push か、依存追跡か）
    
- **UI の再描画単位**（コンポーネントか、式か、atom か）
    
- **開発者が最適化をどれだけ意識する必要があるか**（明示・暗黙）
    

---

## 3. Redux と React の差分レンダリングの仕組み

### ● Redux 本体

- `dispatch` → reducer 実行 → **全 subscriber に通知**
    
- 差分は一切見ない（"state 変わったかも"通知だけ）
    

### ● React-Redux（useSelector）が差分を担当

- selector を毎回実行し、返り値を前回と `===` 比較
    
- **selector の返り値が変わったコンポーネントだけ再レンダリング**
    

### ● レンダリングの流れ

1. dispatch
    
2. Redux が全体通知
    
3. useSelector が selector 結果を比較
    
4. 変わったコンポーネントだけ再レンダー
    

### ● 差分の粒度を決めるのは？

> **slice ではなく selector**

### ● 例：user.name が変わると user 全体が変わる理由

- reducer の immutable update により `state.user` の参照が変わる
    
- selector が `state.user` を返す場合 → 再レンダーされる
    

---

## 4. Redux の slice の意味（差分とは関係ない）

### ● slice は何のため？

1. **ドメイン単位の責務分割**
    
2. **ライフサイクル管理（ログアウトでリセット等）**
    
3. **reducer / actions のモジュール化**
    
4. **状態構造の整理（entities / UI / feature 単位）**
    

### ● slice が差分に影響しない理由

- Redux の通知は全体通知
    
- 再レンダーの粒度は selector が決める
    
- slice を細分化しても selector が変わらなければ UI 再レンダーの粒度は同じ
    

### ● "何も考えずに slice を作る" と起きる問題

- 神 slice 化（肥大化）
    
- ライフサイクルの衝突
    
- 責務の混線（userSlice に UI 状態など混ざる）
    
- 正規化不備によるデータ重複
    

---

## 5. Redux/React と Vue/Pinia の違い

### ● 依存モデルの違い

|観点|Redux/React|Vue/Pinia|
|---|---|---|
|依存検出|selector（明示的）|state の読み取りを Proxy で自動追跡|
|通知粒度|全体通知（Redux 本体）|プロパティ単位（自動）|
|再レンダー判定|selector 返り値の `===`|依存プロパティ変更時のみ|
|依存グラフ|開発者が手で作る（selector = 手書きの依存グラフ）|フレームワークが自動生成（読み取った瞬間に依存が生える）|

### ● 「自動で依存が増える」世界観の違い

- Redux では：
    
    - `useSelector(state => state.user.name)` のように **依存する値を自分で選ぶ**
        
    - selector が「このコンポーネントは何に依存するか」の **明示的な定義** になる
        
    - 依存グラフは「開発者が書いた selector の集合」としてだけ存在する
        
- Vue/Pinia では：
    
    - コンポーネントや computed の中で `store.user.name` を **読み取った瞬間に自動で依存登録**
        
    - 「どの state を読んだか」を Vue が裏で追跡し、依存グラフを構築する
        
    - つまり、**Redux で selector を手書きしていた部分が Pinia ではフレームワーク側で自動生成される** イメージ
        

> 言い換えると、**Vue/Pinia の依存グラフは「Redux に selector が勝手に大量に生えていく世界」** と捉えると分かりやすい。

### ● Redux/React

- UI 再レンダーの粒度は selector が決定（明示的な依存指定）
    
- 依存は増えもしないし減りもしない：**書いた selector 以上の依存は勝手に追加されない**
    
- 明示的で予測可能（アーキテクトが制御しやすい）
    
- その代わり、粒度を細かくしたいなら開発者が selector を丁寧に設計する必要がある
    

### ● Vue/Pinia

- "読み取ったとき" に依存関係が自動で追加される
    
- プロパティ単位で超細かい差分伝搬が可能
    
- ただし、**どこで何を読んでいるかに応じて依存が暗黙的に増える** ため、規模が大きくなると「この変更がどこに波及するか」が見えにくくなる
    

### ● 全体の違いの一言まとめ

> **Redux/React：差分と依存は selector を通じて明示的に設計する世界（依存は勝手には増えない）**
> 
> **Vue/Pinia：state を読むだけで依存が自動的に追加されていく世界（依存グラフはフレームワークが生成）**

この違いが、

- Redux は「予測可能・コントロールしやすいが、最適化は手間」
    
- Vue/Pinia は「書きやすく自動で最適化されるが、依存関係がブラックボックス化しやすい」
    

という性質の差につながっている。