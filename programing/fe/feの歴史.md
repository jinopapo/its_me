## 最初期（サーバーサイドレンダリング主体）
- HTMLはサーバーで生成され、クライアントは表示するだけだった
- ページの内容を変えたい場合はサーバーに再リクエストしてHTMLを再取得する必要があった

### 登場人物
- データ（サーバーが生成した静的な値）

---

## jQuery期（手続き的DOM更新の時代）
- ユーザーイベントに応じてAJAXでデータ取得が可能に
- 生のDOM APIを直接操作する代わりに、jQueryで簡易に部分書き換えができるようになった
- ページ内の一部だけを更新する「動的なUI」が一般化

### この時代の課題
- データが増えると「どのデータ変更がどのDOM要素に影響するか」をすべて手動で追う必要があった
- UIが複雑になると、手続き的DOM操作の整合性維持が難しくなる（更新漏れ・順序依存・意図しない再描画など）

### 登場人物
- データ（サーバーや内部計算で変化する値）
- イベント（クリック/入力など）
- 手続き的なUI更新（jQueryによるDOM操作）

---

## React期（データ→UI の依存関係を宣言的に扱う時代）
- UI が動的に複雑化し、「データとUI要素の紐づけ」を明示する必要が生まれた
- React は **UI = 表示に影響するデータ（＝状態）の関数** という宣言的モデルを導入
- UI更新の手続き（DOM操作）を仮想DOMで抽象化し、「何がどう更新されるか」を意識せず書けるようになった

### 解決したかったこと
- 手続き的DOM更新の複雑性（「どこを書き換えるか」をすべて手で管理する問題）
- データとUIの依存関係が不透明になり、変更に弱いコードになる問題

### Reactの核心
- UIに影響するデータの部分集合を「状態（state）」として明確に区別
  - ※これは“バズワード化した状態管理”ではなく、「UIを決めるために必要な最小データ」
- 状態とそれに依存するUIを **コンポーネント** として局所化（高凝集）
- 状態が変わると、その状態を参照しているUIだけが自動的に更新される世界へ

### 登場人物
- 状態（UIと直接結びつくデータの部分集合）
- データ（状態を含むより広い概念。APIレスポンスなども含む）
- イベント（ユーザーアクション）

---

## 現代（React以降で表面化した課題）
UI が高度化し、複数のコンポーネントから参照・更新される“横断的な状態（グローバルな状態）”が増えた。
これにより、状態更新時に「UI のどこを更新すべきか」を判断することが大きな課題になった。

### 1. 横断的な状態（グローバル状態）の扱いが難しい
コンポーネントをまたいで read / write される状態は、UI ツリーの構造と一致しない。
そのため、状態が変わったときにどの UI を再描画すべきか判断するのが難しくなる。

例:
- 認証ユーザー情報
- APIレスポンスのキャッシュ
- フィルタ条件
- テーマ / 設定情報
- グローバルUI状態（モーダル、レイアウトなど）

### 2. 仮想DOM方式では“更新対象探索”のコストが高い
React は仮想DOMを使うため、どのUIがその状態に依存しているかを事前に把握できず、
**コンポーネントを広範囲に再実行してから差分を探す**必要がある。

- コストが高い
- 再レンダリングの影響範囲が読みにくい
- 横断状態を増やすほど破綻しやすくなる

これにより、横断状態の更新が UI 全体を巻き込んでしまう。

### 3. 状態管理のライブラリごとに「更新範囲の決定方法」が異なり、設計が難しい
Redux, Zustand, Recoil, Jotai, etc. では、
「横断状態が更新されたとき、どのUIを再レンダリングするか」の仕組みが異なる。

例:
- Redux：原則全体購読 → 再レンダリングしがち → selector 必須
- Zustand：subscribe 単位で部分購読できるが、設計の工夫が必要
- Recoil / Jotai：依存関係の自動追跡があるが、API が複雑になりがち

つまり、  
**横断状態そのものが難しいのではなく、  
React の再レンダリングモデルと各ライブラリの部分購読方式が複雑に絡むことで難しくなっている。**

### 4. “真の差分更新だけ” できる仕組みが必要になった
グローバルな状態を安全に扱うには、本来こうあるべき。
- 状態が変わったとき、  その状態を実際に読んでいる UI だけが更新される。
	
しかし仮想DOM方式ではそれを実現できない。

### 5. Signals（依存関係グラフ）による新しいモデル
Signals は、どの UI / ロジックがどの状態に依存しているかを **フレームワーク側が把握** する仕組み。
  
  - signal が更新される  
	  - → signal を読んでいる箇所だけ再実行される  
	  - → UI ツリー全体を探索しなくてよい  
	  - → 差分計算も不要
その結果:

- 横断状態でも更新が局所化される  
- “どこまで再レンダリングが走るか” の予測性が高い  
- React 特有の memo / useCallback / useMemo 最適化が不要  
- 状態がどこに置かれていても破綻しにくい  
- ストアの分割戦略が大幅にシンプルになる

### まとめ
現代で問題になっているのは、
**横断状態そのものではなく、  
React の仮想DOMベースの再レンダリングモデルが横断状態と相性が悪いこと。**

Signals のような依存追跡ベースのレンダリングモデルでは、
横断状態であっても必要な部分だけが更新されるため、
状態の配置・分割・再レンダリング最適化の難しさが大幅に減る。